/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package bitmap.transformer;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import javax.imageio.ImageIO;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.nio.file.Path;
import java.nio.file.Paths;

import static org.junit.jupiter.api.Assertions.*;

class BitmapTest {
    // Declaring ANSI_RESET so that we can reset the color
    public static final String ANSI_RESET = "\u001B[0m";
    // Declaring ANSI_GREEN to color the successful test souts :)
    public static final String ANSI_GREEN = "\u001B[32m";
    private Path flippedFilePath;
    private Path grayscaleFilePath;
    private Path invertedFilePath;
    private Bitmap actualBitmap;

    // The overall approach for this is that I've created the equivalent transforms in Photoshop, and we check that each pixel RGB is equivalent to the Bitmap class output

    @BeforeEach
    public void setUp() throws IOException {
        Path filePath = Paths.get("src/test/resources/test.bmp");
        flippedFilePath = Paths.get("src/test/resources/test-flip-horizontally.bmp");
        grayscaleFilePath = Paths.get("src/test/resources/test-grayscale.bmp");
        invertedFilePath = Paths.get("src/test/resources/test-invert-colors.bmp");
        actualBitmap = new Bitmap(filePath);
    }
    @Test
    public void testFlipHorizontally() throws IOException {
        actualBitmap.flipHorizontally();
        BufferedImage expectedBitmap = ImageIO.read(flippedFilePath.toFile());
        compareImageDimensions(expectedBitmap, actualBitmap.getBitmap());
        comparePixelRGB(expectedBitmap, actualBitmap.getBitmap());
        System.out.println(ANSI_GREEN + "testFlipHorizontally() - test passed successfully" + ANSI_RESET);
    }

    @Test
    public void testGrayscale() throws IOException {
        actualBitmap.toGrayscale();
        BufferedImage expectedBitmap = ImageIO.read(grayscaleFilePath.toFile());
        compareImageDimensions(expectedBitmap, actualBitmap.getBitmap());
        comparePixelRGB(expectedBitmap, actualBitmap.getBitmap());
        System.out.println(ANSI_GREEN + "testGrayscale() - test passed successfully" + ANSI_RESET);
    }

    @Test
    public void testInvertColors() throws IOException {
        actualBitmap.invertColors();
        BufferedImage expectedBitmap = ImageIO.read(invertedFilePath.toFile());
        compareImageDimensions(expectedBitmap, actualBitmap.getBitmap());
        comparePixelRGB(expectedBitmap, actualBitmap.getBitmap());
        System.out.println(ANSI_GREEN + "testInvertColors() - test passed successfully" + ANSI_RESET);
    }

    public void compareImageDimensions(BufferedImage expectedBitmap, BufferedImage actualBitmap) {
        // Make sure the images are the same heights and widths
        int expectedWidth = expectedBitmap.getWidth();
        int actualWidth = actualBitmap.getWidth();
        int expectedHeight = expectedBitmap.getHeight();
        int actualHeight = actualBitmap.getHeight();
        assertEquals(expectedWidth, actualWidth);
        assertEquals(expectedHeight, actualHeight);
    }

    public void comparePixelRGB(BufferedImage expectedBitmap, BufferedImage actualBitmap) {
        // Loop through each pixel and compare RGB values
        for (int row = 0; row < expectedBitmap.getHeight(); row++) {
            for (int column = 0; column < expectedBitmap.getWidth(); column++) {
                assertEquals(expectedBitmap.getRGB(column, row),
                        actualBitmap.getRGB(column, row));
            }
        }
    }
}
